

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>P2DingoCV.PanelSegmentation.PanelSegmentor &mdash; P2DingoCV 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            P2DingoCV
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/P2DingoCV.html">P2DingoCV</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Camera.html">P2DingoCV.Camera</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Camera.Camera.html">P2DingoCV.Camera.Camera</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Camera.Camera.html#P2DingoCV.Camera.Camera.Camera"><code class="docutils literal notranslate"><span class="pre">Camera</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Camera.CameraFactory.html">P2DingoCV.Camera.CameraFactory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Camera.CameraFactory.html#P2DingoCV.Camera.CameraFactory.CameraFactory"><code class="docutils literal notranslate"><span class="pre">CameraFactory</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Camera.ImageCamera.html">P2DingoCV.Camera.ImageCamera</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Camera.ImageCamera.html#P2DingoCV.Camera.ImageCamera.ImageCamera"><code class="docutils literal notranslate"><span class="pre">ImageCamera</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Camera.VideoCamera.html">P2DingoCV.Camera.VideoCamera</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Camera.VideoCamera.html#P2DingoCV.Camera.VideoCamera.VideoCamera"><code class="docutils literal notranslate"><span class="pre">VideoCamera</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../_autosummary/P2DingoCV.HotspotLogic.html">P2DingoCV.HotspotLogic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.HotspotLogic.Exceptions.html">P2DingoCV.HotspotLogic.Exceptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/P2DingoCV.HotspotLogic.Exceptions.TempDetectionFail.html">P2DingoCV.HotspotLogic.Exceptions.TempDetectionFail</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.HotspotLogic.HotspotDetector.html">P2DingoCV.HotspotLogic.HotspotDetector</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/P2DingoCV.HotspotLogic.HotspotDetector.html#P2DingoCV.HotspotLogic.HotspotDetector.HotspotDetector"><code class="docutils literal notranslate"><span class="pre">HotspotDetector</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../_autosummary/P2DingoCV.PanelSegmentation.html">P2DingoCV.PanelSegmentation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html">P2DingoCV.PanelSegmentation.PanelSegmentor</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor"><code class="docutils literal notranslate"><span class="pre">PanelSegmentor</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Types.html">P2DingoCV.Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Types.Types.html">P2DingoCV.Types.Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Util.html">P2DingoCV.Util</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Util.MiscUtil.html">P2DingoCV.Util.MiscUtil</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Util.MiscUtil.html#P2DingoCV.Util.MiscUtil.MiscUtil"><code class="docutils literal notranslate"><span class="pre">MiscUtil</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Util.VisualUtil.html">P2DingoCV.Util.VisualUtil</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../_autosummary/P2DingoCV.Util.VisualUtil.html#P2DingoCV.Util.VisualUtil.VisualUtils"><code class="docutils literal notranslate"><span class="pre">VisualUtils</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../_autosummary/P2DingoCV.cli.html">P2DingoCV.cli</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.cli.html#P2DingoCV.cli.main"><code class="docutils literal notranslate"><span class="pre">main()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.cli.html#P2DingoCV.cli.runMaximal"><code class="docutils literal notranslate"><span class="pre">runMaximal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.cli.html#P2DingoCV.cli.runMinimal"><code class="docutils literal notranslate"><span class="pre">runMinimal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.cli.html#P2DingoCV.cli.runVerbose"><code class="docutils literal notranslate"><span class="pre">runVerbose()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/P2DingoCV.cli.html#P2DingoCV.cli.runVisual"><code class="docutils literal notranslate"><span class="pre">runVisual()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">P2DingoCV</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">P2DingoCV.PanelSegmentation.PanelSegmentor</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for P2DingoCV.PanelSegmentation.PanelSegmentor</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">logging</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cv</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">lines</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Final</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.patches</span><span class="w"> </span><span class="kn">import</span> <span class="n">Circle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..Types.Types</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArray</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..Util.MiscUtil</span><span class="w"> </span><span class="kn">import</span> <span class="n">MiscUtil</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..Util.VisualUtil</span><span class="w"> </span><span class="kn">import</span> <span class="n">VisualUtils</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>



<div class="viewcode-block" id="PanelSegmentor">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PanelSegmentor</span><span class="p">:</span>
<div class="viewcode-block" id="PanelSegmentor.__init__">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">outputPath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PanelSegmentor class for detecting and segmenting panel-like regions in an image.</span>

<span class="sd">        This segmentor uses a combination of denoising, edge detection, and Hough line</span>
<span class="sd">        transform techniques to identify candidate panels based on expected line counts,</span>
<span class="sd">        aspect ratios, and image characteristics.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lineCount : int</span>
<span class="sd">            Expected number of lines in the image for line detection. This is an approximate</span>
<span class="sd">            value and does not need to be precise.</span>
<span class="sd">        lineBuffer : int</span>
<span class="sd">            Pixel buffer added around detected lines to extend candidate regions.</span>
<span class="sd">        denoiseLambdaWeight : float</span>
<span class="sd">            Weight factor for the denoising algorithm. Higher values prioritize smoothness</span>
<span class="sd">            over detail preservation.</span>
<span class="sd">        denoiseMeanKernelSize : int</span>
<span class="sd">            Kernel size for the mean/average filter applied during denoising.</span>
<span class="sd">        denoiseGaussianSigma : float</span>
<span class="sd">            Standard deviation for Gaussian smoothing during denoising.</span>
<span class="sd">        denoiseDownsampleFactor : float</span>
<span class="sd">            Factor to downsample input frames before applying denoising, reducing computation.</span>
<span class="sd">        edgeSlideFactor : float</span>
<span class="sd">            Initial sliding window size for edge detection. The algorithm adjusts this dynamically.</span>
<span class="sd">        clipLimit : float</span>
<span class="sd">            Clip limit for CLAHE (Contrast Limited Adaptive Histogram Equalization) to enhance</span>
<span class="sd">            local contrast.</span>
<span class="sd">        rho : float</span>
<span class="sd">            Distance resolution in pixels for the Hough line transform.</span>
<span class="sd">        theta : float</span>
<span class="sd">            Angle resolution in radians for the Hough line transform.</span>
<span class="sd">        aspectRatio : float</span>
<span class="sd">            Expected width-to-height ratio for candidate panel regions.</span>
<span class="sd">        sigmaMultipler : float</span>
<span class="sd">            Multiplier for Gaussian sigma used in edge detection or smoothing, relative to image diagonal.</span>
<span class="sd">        edgeThresholdMultiplier : float</span>
<span class="sd">            Multiplier applied to edge detection thresholds, scaled by image diagonal.</span>
<span class="sd">        minLineLengthMultipler : float</span>
<span class="sd">            Multiplier to determine the minimum line length for line detection, relative to image diagonal.</span>
<span class="sd">        maxLineGapMultipler : float</span>
<span class="sd">            Multiplier to determine the maximum allowed gap between line segments, relative to image diagonal.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The parameters involving &quot;multipliers&quot; (sigmaMultipler, edgeThresholdMultiplier, </span>
<span class="sd">        minLineLengthMultipler, maxLineGapMultipler) are scaled relative to the image diagonal</span>
<span class="sd">        to make the algorithm more robust across different image resolutions.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        segmentor = PanelSegmentor(</span>
<span class="sd">            lineCount=5,</span>
<span class="sd">            lineBuffer=10,</span>
<span class="sd">            denoiseLambdaWeight=0.8,</span>
<span class="sd">            denoiseMeanKernelSize=5,</span>
<span class="sd">            denoiseGaussianSigma=1.5,</span>
<span class="sd">            denoiseDownsampleFactor=2.0,</span>
<span class="sd">            edgeSlideFactor=5.0,</span>
<span class="sd">            clipLimit=2.0,</span>
<span class="sd">            rho=1,</span>
<span class="sd">            theta=0.0174533,</span>
<span class="sd">            aspectRatio=1.5,</span>
<span class="sd">            sigmaMultipler=0.02,</span>
<span class="sd">            edgeThresholdMultiplier=0.05,</span>
<span class="sd">            minLineLengthMultipler=0.1,</span>
<span class="sd">            maxLineGapMultipler=0.02</span>
<span class="sd">            </span>
<span class="sd">        )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frameCount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">outputPath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visualUtil</span><span class="p">:</span> <span class="n">VisualUtils</span> <span class="o">=</span> <span class="n">VisualUtils</span><span class="p">(</span><span class="n">outputPath</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="n">MiscUtil</span><span class="o">.</span><span class="n">loadConfig</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="c1"># Parmaters dependant on resolution</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_params</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernelSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;kernelSize&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clipLimit</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;clipLimit&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tileGridSize</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;tileGridSize&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;edgeSlideFactor&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;threshold&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minLineLength</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;minLineLength&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxLineGap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;maxLineGap&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineCount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;lineCount&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineBuffer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;lineBuffer&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">denoiseLambdaWeight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;denoiseLambdaWeight&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">denoiseMeanKernelSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;denoiseMeanKernelSize&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">denoiuseGaussianSigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;denoiuseGaussianSigma&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">denoiseDownsampleFactor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;denoiseDownsampleFactor&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="PanelSegmentor.normalize_params">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.normalize_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">normalize_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Constants</span>
        <span class="n">diag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">width</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="n">kernelSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.005</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># odd</span>
        <span class="n">tileGridSize</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">64</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">height</span> <span class="o">//</span> <span class="mi">64</span><span class="p">))</span>

        <span class="c1"># Config params</span>
        <span class="n">lineCount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lineCount&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">lineBuffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lineBuffer&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">denoiseLambdaWeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;denoiseLambdaWeight&quot;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">denoiseMeanKernelSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;denoiseMeanKernelSize&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">denoiuseGaussianSigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;denoiuseGaussianSigma&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">denoiseDownsampleFactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;denoiseDownsampleFactor&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">edgeSlideFactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edgeSlideFactor&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">clipLimit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;clipLimit&quot;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rho&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;theta&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>
        <span class="n">aspectRatio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;aspectRatio&quot;</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">1.7</span><span class="p">)</span>

        <span class="c1"># Modifiers</span>
        <span class="n">sigmaMultipler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sigmaMultipler&quot;</span><span class="p">,</span> <span class="mf">0.010</span><span class="p">)</span>
        <span class="n">edgeThresholdMultiplier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edgeThresholdMultiplier&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
        <span class="n">minLineLengthMutiplier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;minLineLengthMutiplier&quot;</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">)</span>
        <span class="n">maxLineGapMultipler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;maxLineGapMultipler&quot;</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">)</span>

        <span class="c1"># 2202.90717008  for 1080p</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">sigmaMultipler</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">diag</span> <span class="o">*</span> <span class="n">edgeThresholdMultiplier</span><span class="p">)</span>
        <span class="n">minLineLength</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">diag</span> <span class="o">*</span> <span class="n">minLineLengthMutiplier</span><span class="p">)</span>
        <span class="n">maxLineGap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">diag</span> <span class="o">*</span> <span class="n">maxLineGapMultipler</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;aspectRatio&quot;</span><span class="p">:</span> <span class="n">aspectRatio</span><span class="p">,</span>
            <span class="s2">&quot;kernelSize&quot;</span><span class="p">:</span> <span class="n">kernelSize</span><span class="p">,</span>
            <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="n">sigma</span><span class="p">,</span>
            <span class="s2">&quot;edgeSlideFactor&quot;</span><span class="p">:</span> <span class="n">edgeSlideFactor</span><span class="p">,</span>
            <span class="s2">&quot;clipLimit&quot;</span><span class="p">:</span> <span class="n">clipLimit</span><span class="p">,</span>
            <span class="s2">&quot;tileGridSize&quot;</span><span class="p">:</span> <span class="n">tileGridSize</span><span class="p">,</span>
            <span class="s2">&quot;rho&quot;</span><span class="p">:</span> <span class="n">rho</span><span class="p">,</span>
            <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="n">theta</span><span class="p">,</span>
            <span class="s2">&quot;threshold&quot;</span><span class="p">:</span> <span class="n">threshold</span><span class="p">,</span>
            <span class="s2">&quot;minLineLength&quot;</span><span class="p">:</span> <span class="n">minLineLength</span><span class="p">,</span>
            <span class="s2">&quot;maxLineGap&quot;</span><span class="p">:</span> <span class="n">maxLineGap</span><span class="p">,</span>
            <span class="s2">&quot;lineCount&quot;</span><span class="p">:</span> <span class="n">lineCount</span><span class="p">,</span>
            <span class="s2">&quot;lineBuffer&quot;</span><span class="p">:</span> <span class="n">lineBuffer</span><span class="p">,</span>
            <span class="s2">&quot;denoiseLambdaWeight&quot;</span><span class="p">:</span> <span class="n">denoiseLambdaWeight</span><span class="p">,</span>
            <span class="s2">&quot;denoiseMeanKernelSize&quot;</span><span class="p">:</span> <span class="n">denoiseMeanKernelSize</span><span class="p">,</span>
            <span class="s2">&quot;denoiuseGaussianSigma&quot;</span><span class="p">:</span> <span class="n">denoiuseGaussianSigma</span><span class="p">,</span>
            <span class="s2">&quot;denoiseDownsampleFactor&quot;</span><span class="p">:</span> <span class="n">denoiseDownsampleFactor</span><span class="p">,</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="PanelSegmentor.resetParameters">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.resetParameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resetParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">logPath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_params</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aspectRatio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;aspectRatio&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernelSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;kernelSize&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clipLimit</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;clipLimit&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tileGridSize</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;tileGridSize&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;edgeSlideFactor&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;threshold&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minLineLength</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;minLineLength&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxLineGap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;maxLineGap&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineCount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;lineCount&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineBuffer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;lineBuffer&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">denoiseLambdaWeight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;denoiseLambdaWeight&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">denoiseMeanKernelSize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;denoiseMeanKernelSize&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">denoiuseGaussianSigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;denoiuseGaussianSigma&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">denoiseDownsampleFactor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;denoiseDownsampleFactor&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="PanelSegmentor.preProcess">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.preProcess">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">preProcess</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">frame</span><span class="p">:</span> <span class="n">Frame</span><span class="p">,</span>
        <span class="n">lambdaWeight</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">meanKernelSizeL</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">gaussianSigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">downsampleFactor</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess an input image frame using guided filtering and edge enhancement,</span>
<span class="sd">        followed by grayscale conversion and Gaussian denoising.</span>

<span class="sd">        This pipeline enhances structural edges while suppressing noise, making the</span>
<span class="sd">        output suitable for downstream tasks such as line detection, grid extraction,</span>
<span class="sd">        or feature analysis.</span>

<span class="sd">        The processing steps are:</span>
<span class="sd">            1. Normalize the input frame to float32 in the range [0, 1].</span>
<span class="sd">            2. Split into color channels.</span>
<span class="sd">            3. Downsample each channel.</span>
<span class="sd">            4. Generate a guidance image using mean filtering.</span>
<span class="sd">            5. Upsample the guidance image and apply guided filtering.</span>
<span class="sd">            6. Perform edge enhancement using: Ai = Qi + λ (Ii − Qi).</span>
<span class="sd">            7. Merge enhanced channels.</span>
<span class="sd">            8. Convert to grayscale.</span>
<span class="sd">            9. Apply Gaussian blur for final denoising.</span>

<span class="sd">        Args:</span>
<span class="sd">            frame (Frame):</span>
<span class="sd">                Input image frame in BGR format. Expected as a NumPy array</span>
<span class="sd">                of dtype uint8 or float32 with shape (H, W, 3).</span>

<span class="sd">            lambdaWeight (float):</span>
<span class="sd">                Edge enhancement strength λ. Higher values increase edge contrast.</span>

<span class="sd">            meanKernelSizeL (int):</span>
<span class="sd">                Kernel size for the mean filter used to generate the guidance image.</span>

<span class="sd">            gaussianSigma (float):</span>
<span class="sd">                Standard deviation for the final Gaussian denoising filter.</span>

<span class="sd">            downsampleFactor (int):</span>
<span class="sd">                Downsampling factor applied before guidance image computation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Frame:</span>
<span class="sd">                A single-channel (grayscale) denoised image frame suitable for</span>
<span class="sd">                further processing.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError:</span>
<span class="sd">                If the input frame has an unexpected shape or dtype.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - Requires OpenCV&#39;s ximgproc module for guided filtering.</span>
<span class="sd">            - Kernel sizes should be positive odd integers for best results.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lambda_weight</span> <span class="o">=</span> <span class="n">lambdaWeight</span>  <span class="c1"># Edge enhancement strength (λ)</span>
        <span class="n">mean_kernel_size</span> <span class="o">=</span> <span class="n">meanKernelSizeL</span>  <span class="c1"># Mean filter size for guidance image</span>
        <span class="n">gaussian_sigma</span> <span class="o">=</span> <span class="n">gaussianSigma</span>  <span class="c1"># Gaussian filter strength</span>
        <span class="n">downsample_factor</span> <span class="o">=</span> <span class="n">downsampleFactor</span>  <span class="c1"># Downsampling ratio</span>
        <span class="c1"># Convert to float32 and normalize to [0, 1]</span>
        <span class="n">I</span><span class="p">:</span> <span class="n">FloatFrame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span>

        <span class="c1"># Split into channels</span>
        <span class="n">I_channels</span><span class="p">:</span> <span class="n">ChannelList</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

        <span class="n">enhanced_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Frame</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Guided filtering and edge enhancement ---</span>
        <span class="k">for</span> <span class="n">Ii</span> <span class="ow">in</span> <span class="n">I_channels</span><span class="p">:</span>
            <span class="c1"># Downsample</span>
            <span class="n">small</span><span class="p">:</span> <span class="n">Channel</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                <span class="n">Ii</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="n">fx</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">downsample_factor</span><span class="p">,</span>
                <span class="n">fy</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">downsample_factor</span><span class="p">,</span>
                <span class="n">interpolation</span><span class="o">=</span><span class="n">cv</span><span class="o">.</span><span class="n">INTER_AREA</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Guidance image Gi = mean filter of downsampled image</span>
            <span class="n">Gi</span><span class="p">:</span> <span class="n">Channel</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">blur</span><span class="p">(</span><span class="n">small</span><span class="p">,</span> <span class="p">(</span><span class="n">mean_kernel_size</span><span class="p">,</span> <span class="n">mean_kernel_size</span><span class="p">))</span>

            <span class="c1"># Upsample Gi back to original size for guided filtering</span>
            <span class="n">Gi_up</span><span class="p">:</span> <span class="n">Channel</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                <span class="n">Gi</span><span class="p">,</span> <span class="p">(</span><span class="n">Ii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Ii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv</span><span class="o">.</span><span class="n">INTER_LINEAR</span>
            <span class="p">)</span>

            <span class="c1"># Guided filter using Gi as guide</span>
            <span class="c1"># OpenCV provides ximgproc.guidedFilter (if available)</span>
            <span class="n">guided</span><span class="p">:</span> <span class="n">Channel</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">ximgproc</span><span class="o">.</span><span class="n">guidedFilter</span><span class="p">(</span>
                <span class="n">guide</span><span class="o">=</span><span class="n">Gi_up</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">Ii</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span>
            <span class="p">)</span>

            <span class="n">Qi</span><span class="p">:</span> <span class="n">Channel</span> <span class="o">=</span> <span class="n">guided</span>

            <span class="c1"># Edge enhancement Ai = Qi + λ (Ii − Qi)</span>
            <span class="n">Ai</span><span class="p">:</span> <span class="n">Channel</span> <span class="o">=</span> <span class="n">Qi</span> <span class="o">+</span> <span class="n">lambda_weight</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ii</span> <span class="o">-</span> <span class="n">Qi</span><span class="p">)</span>
            <span class="n">enhanced_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">Ai</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1">#  Merge enhanced channels</span>
        <span class="n">A</span><span class="p">:</span> <span class="n">Frame</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">enhanced_channels</span><span class="p">)</span>

        <span class="c1"># Convert to grayscale for final denoising</span>
        <span class="n">A_gray</span><span class="p">:</span> <span class="n">Frame</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">((</span><span class="n">A</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

        <span class="c1"># Gaussian filter to suppress noise</span>
        <span class="n">A_denoised</span><span class="p">:</span> <span class="n">Frame</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span>
            <span class="n">A_gray</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernelSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernelSize</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">A_denoised</span></div>


<div class="viewcode-block" id="PanelSegmentor.edgeDetection">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.edgeDetection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edgeDetection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span> <span class="n">Frame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform adaptive Canny edge detection based on the median intensity</span>
<span class="sd">        of the input frame.</span>

<span class="sd">        The lower and upper Canny thresholds are computed through a loop that converges on</span>
<span class="sd">        a number of detected lines close to the expected line count.</span>

<span class="sd">        Thresholds are computed as:</span>
<span class="sd">            v = edgeSlideFactor * median(frame)</span>
<span class="sd">            lower = max(0, (1 - σ) * v)</span>
<span class="sd">            upper = min(255, (1 + σ) * v)</span>

<span class="sd">        Args:</span>
<span class="sd">            frame (Frame):</span>
<span class="sd">                Input image frame, expected to be a single-channel (grayscale)</span>
<span class="sd">                or 3-channel image in uint8 format.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Frame:</span>
<span class="sd">                A single-channel binary edge map produced by the Canny detector.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - Uses OpenCV&#39;s Canny edge detector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.33</span>
        <span class="n">v</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">frame</span><span class="p">))</span>
        <span class="n">lower</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">))</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">))</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">Canny</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">edges</span></div>


<div class="viewcode-block" id="PanelSegmentor.lineDetection">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.lineDetection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lineDetection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span> <span class="n">Frame</span><span class="p">,</span> <span class="n">expectedLines</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span> <span class="n">Frame</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect line segments in an image using adaptive Canny + Hough Transform.</span>

<span class="sd">        This method iteratively adjusts the edge detection sensitivity</span>
<span class="sd">        (`edgeSlideFactor`) to converge on an expected number of detected</span>
<span class="sd">        line segments. It is designed to be robust across varying contrast</span>
<span class="sd">        and noise conditions.</span>

<span class="sd">        The process is:</span>
<span class="sd">            1. Apply adaptive Canny edge detection.</span>
<span class="sd">            2. Detect line segments using probabilistic Hough transform.</span>
<span class="sd">            3. Adjust edge sensitivity until the number of detected lines</span>
<span class="sd">               falls within the acceptable buffer range.</span>

<span class="sd">        Args:</span>
<span class="sd">            frame (Frame):</span>
<span class="sd">                Input image frame (typically grayscale) used for line detection.</span>

<span class="sd">            expectedLines (int, optional):</span>
<span class="sd">                Target number of line segments to detect. The algorithm</span>
<span class="sd">                adapts thresholds to approach this value. Defaults to 100.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[np.ndarray, Frame] | None:</span>
<span class="sd">                A tuple containing:</span>
<span class="sd">                    - lines: NumPy array of shape (N, 4), where each row is</span>
<span class="sd">                      (x1, y1, x2, y2) for a detected line segment.</span>
<span class="sd">                    - edges: The binary edge image used for Hough detection.</span>

<span class="sd">                Returns None only if no valid detection occurs (normally a</span>
<span class="sd">                ValueError is raised instead).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError:</span>
<span class="sd">                If no lines are detected after exhausting all threshold adjustments,</span>
<span class="sd">                or if the detection logic enters an invalid state.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - Uses OpenCV&#39;s cv.HoughLinesP for line detection.</span>
<span class="sd">            - The parameter `edgeSlideFactor` is automatically tuned per frame.</span>
<span class="sd">            - `lineBuffer` defines the acceptable deviation from `expectedLines`.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">detectionSuccess</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">=</span> <span class="mf">5.0</span>  <span class="c1"># reset for each frame</span>
        <span class="n">prevBig</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">prevSmall</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting line detection with target of </span><span class="si">{</span><span class="n">expectedLines</span><span class="si">}</span><span class="s2"> lines.&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">detectionSuccess</span><span class="p">:</span>
            <span class="n">increment</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.03</span>
            <span class="n">edges</span><span class="p">:</span> <span class="n">Frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgeDetection</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
            <span class="n">lines</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">HoughLinesP</span><span class="p">(</span>
                <span class="n">edges</span><span class="p">,</span>
                <span class="n">rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span>
                <span class="n">theta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span>
                <span class="n">minLineLength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">minLineLength</span><span class="p">,</span>
                <span class="n">maxLineGap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxLineGap</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge slide factor: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">-=</span> <span class="mf">0.25</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">detectionSuccess</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No lines detected.&quot;</span><span class="p">)</span>
            <span class="c1"># ideal case</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">expectedLines</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineBuffer</span>
                <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
                <span class="o">&lt;=</span> <span class="n">expectedLines</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineBuffer</span>
            <span class="p">):</span>
                <span class="n">detectionSuccess</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">prevBig</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">prevSmall</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">increment</span> <span class="o">=</span> <span class="mf">0.03</span>
            <span class="c1"># prevent falling into negatives</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">expectedLines</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineBuffer</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">prevSmall</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
                    <span class="n">increment</span> <span class="o">/=</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">+=</span> <span class="n">increment</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">+=</span> <span class="n">increment</span>
                
                <span class="n">prevBig</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">expectedLines</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineBuffer</span> <span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">prevBig</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
                    <span class="n">increment</span> <span class="o">/=</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">-=</span> <span class="n">increment</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edgeSlideFactor</span> <span class="o">-=</span> <span class="n">increment</span>
                <span class="n">prevSmall</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Line detection logic error.&quot;</span><span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="si">}</span><span class="s2"> lines.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">edges</span></div>


<div class="viewcode-block" id="PanelSegmentor.mergeLines">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.mergeLines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mergeLines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">angle_thresh</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
        <span class="n">dist_thresh</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge approximately collinear and nearby line segments into longer &quot;superlines&quot;.</span>

<span class="sd">        This function groups 2D line segments that have similar orientation (within</span>
<span class="sd">        `angle_thresh`) and are spatially close (within `dist_thresh` measured along</span>
<span class="sd">        the normal direction). For each group, it fits a single representative line</span>
<span class="sd">        using PCA and returns the endpoints of the merged segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lines : NDArray[np.integer]</span>
<span class="sd">            Array of line segments with shape (N, 4), where each row is</span>
<span class="sd">            [x1, y1, x2, y2].</span>
<span class="sd">        angle_thresh : float, optional</span>
<span class="sd">            Maximum angular difference (in radians) between two lines for them</span>
<span class="sd">            to be considered collinear. Default is 5 degrees in radians.</span>
<span class="sd">        dist_thresh : int, optional</span>
<span class="sd">            Maximum perpendicular distance (in pixels) between two lines for them</span>
<span class="sd">            to be considered part of the same group. Default is 50.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray[np.integer]</span>
<span class="sd">            Array of merged line segments with shape (M, 4), where each row is</span>
<span class="sd">            [x1, y1, x2, y2] representing the endpoints of a fitted &quot;superline&quot;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The algorithm:</span>
<span class="sd">        </span>
<span class="sd">        1. Iterates over all input lines.</span>
<span class="sd">        2. Groups lines with similar angle and nearby perpendicular offset.</span>
<span class="sd">        3. Collects all endpoints from each group.</span>
<span class="sd">        4. Fits a line using PCA to find the dominant direction.</span>
<span class="sd">        5. Projects points onto that direction and uses min/max projections</span>
<span class="sd">            as the merged segment endpoints.</span>
<span class="sd">            </span>
<span class="sd">        - Output endpoints are rounded to integer pixel coordinates.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">used</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">merged</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">theta1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">n</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)])</span>
            <span class="n">n</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">pts</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">],</span> <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]])</span>

            <span class="c1"># normal vector for distance checks</span>
            <span class="n">rho1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">],</span> <span class="n">n</span><span class="p">))</span>

            <span class="c1"># Collect lines to merge</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="n">y4</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">theta2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y4</span> <span class="o">-</span> <span class="n">y3</span><span class="p">,</span> <span class="n">x4</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span>

                <span class="n">dtheta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">theta1</span> <span class="o">-</span> <span class="n">theta2</span><span class="p">)</span>
                <span class="n">dtheta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dtheta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">dtheta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dtheta</span> <span class="o">&lt;</span> <span class="n">angle_thresh</span><span class="p">:</span>
                    <span class="n">rho2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">],</span> <span class="n">n</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rho1</span> <span class="o">-</span> <span class="n">rho2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dist_thresh</span><span class="p">:</span>
                        <span class="n">pts</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="p">[[</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">],</span> <span class="p">[</span><span class="n">x4</span><span class="p">,</span> <span class="n">y4</span><span class="p">]])</span>
                        <span class="p">)</span>
                        <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Fit a superline using PCA (via NumPy)</span>
            <span class="n">mean</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">cov</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">pts</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">eigvals</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
            <span class="n">eigvecs</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
            <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
            <span class="n">direction</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)]</span>

            <span class="c1"># Project all points onto the direction vector</span>
            <span class="n">projections</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pts</span> <span class="o">-</span> <span class="n">mean</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
            <span class="n">p1</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">projections</span><span class="p">)</span>
            <span class="n">p2</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">projections</span><span class="p">)</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">))</span>
            <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span></div>


<div class="viewcode-block" id="PanelSegmentor.angleClusters">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.angleClusters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">angleClusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span>
        <span class="n">Tuple</span><span class="p">[</span>
            <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
            <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
            <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
            <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="o">|</span> <span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cluster line segments by orientation using circular k-means.</span>

<span class="sd">        This function takes 2D line segments, computes their orientation angles</span>
<span class="sd">        (in degrees), maps them into a circular-safe representation, and clusters</span>
<span class="sd">        them into `k` groups using k-means. It is robust to wrap-around effects</span>
<span class="sd">        (e.g., near 0°/180°) by using absolute deltas and modulo arithmetic.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lines : NDArray[np.integer] | None</span>
<span class="sd">            Array of line segments with shape (N, 4), where each row is</span>
<span class="sd">            [x1, y1, x2, y2]. Typically from HoughLinesP. If None or empty,</span>
<span class="sd">            the function returns None.</span>
<span class="sd">        k : int, optional</span>
<span class="sd">            Number of orientation clusters to form. Default is 2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[NDArray[np.float64], NDArray[np.integer], NDArray[np.float64], NDArray[np.float64]] | None</span>
<span class="sd">            If input is valid, returns a 4-tuple:</span>
<span class="sd">            - pts : (N, 2) array of unit-circle coordinates used for clustering</span>
<span class="sd">            - labels : (N,) array of cluster indices for each line</span>
<span class="sd">            - centersXY : (k, 2) array of cluster centers in unit-circle space</span>
<span class="sd">            - centersDeg : (k,) array of cluster center angles in degrees [0, 180)</span>

<span class="sd">            Returns None if `lines` is None or empty.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Line angles are computed using atan2() and wrapped to [0, 180)</span>
<span class="sd">            to treat lines as undirected.</span>
<span class="sd">        - Clustering is performed by `self.KmeansCluster`, which handles the</span>
<span class="sd">            circular nature of angular data.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reshape if needed (HoughLinesP returns with double wrapped arrays)</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">x1</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
        <span class="n">y1</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
        <span class="n">y2</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lines</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lines</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">lines</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>

        <span class="c1"># calculate deltas as abs to solve the wrap around issue</span>
        <span class="n">dx</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
        <span class="n">dy</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>

        <span class="n">anglesDeg</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span> <span class="o">%</span> <span class="mi">180</span>

        <span class="n">output</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span>
            <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
            <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
            <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
            <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">KmeansCluster</span><span class="p">(</span><span class="n">anglesDeg</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="PanelSegmentor.KmeansCluster">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.KmeansCluster">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">KmeansCluster</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">angles</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">maxIter</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">randomState</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cluster line orientations (in degrees) using circular k-means on the unit circle.</span>

<span class="sd">        This function takes angles in degrees in the range [0, 180], maps them onto</span>
<span class="sd">        the unit circle to handle circularity (so 0° and 180° are close), performs</span>
<span class="sd">        k-means clustering, and converts the resulting cluster centers back to angles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angles : np.ndarray</span>
<span class="sd">            Array of angles in degrees, expected in the range [0, 180].</span>
<span class="sd">        k : int, optional</span>
<span class="sd">            Number of clusters. Default is 2.</span>
<span class="sd">        maxIter : int, optional</span>
<span class="sd">            Maximum number of k-means iterations. Default is 300.</span>
<span class="sd">        randomState : Optional[int], optional</span>
<span class="sd">            Random seed for reproducibility. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pts : NDArray[np.float64]</span>
<span class="sd">            Points on the unit circle corresponding to the input angles, shape (N, 2).</span>
<span class="sd">        labels : NDArray[np.integer]</span>
<span class="sd">            Cluster labels for each input angle, shape (N,).</span>
<span class="sd">        centersXY : NDArray[np.float64]</span>
<span class="sd">            Cluster centers in unit-circle (x, y) coordinates, shape (k, 2).</span>
<span class="sd">        centersDeg : NDArray[np.float64]</span>
<span class="sd">            Cluster centers converted back to angles in degrees in the range [0, 180).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any input angle is outside the range [0, 180].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">angles</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">angles</span> <span class="o">&gt;</span> <span class="mi">180</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All angles must be in the range [0, 180].&quot;</span><span class="p">)</span>

        <span class="n">theta</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>

        <span class="c1"># Map angles onto unit circle so 0 and 180 are close:</span>
        <span class="n">pts</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)])</span>

        <span class="n">km</span><span class="p">:</span> <span class="n">KMeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">maxIter</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">randomState</span><span class="p">)</span>
        <span class="n">km</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">km</span><span class="o">.</span><span class="n">labels_</span>

        <span class="c1"># Convert cluster centres back into angles:</span>
        <span class="n">cx</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
        <span class="n">cy</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">km</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">km</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">center_theta</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">)</span>
        <span class="c1"># atan2 returns in (–π, π]; map to [0, 2π):</span>
        <span class="n">center_theta</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">center_theta</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="c1"># Map back to [0, 180) degrees:</span>
        <span class="n">centersDeg</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">center_theta</span> <span class="o">*</span> <span class="p">(</span><span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pts</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">km</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">,</span> <span class="n">centersDeg</span></div>


    <span class="c1">############### Visualisation Functions ###########################</span>

<div class="viewcode-block" id="PanelSegmentor.groupAndFilter">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.groupAndFilter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">groupAndFilter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">frame</span><span class="p">,</span>
        <span class="n">lines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">discardPercentageofMedian</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Frame</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove noisy/short Hough lines and separate them into horizontal and vertical sets.</span>

<span class="sd">        This function performs a full cleanup pipeline on detected line segments:</span>
<span class="sd">        1. Discards obvious outliers using k-means clustering.</span>
<span class="sd">        2. Iteratively merges nearly parallel and spatially close lines.</span>
<span class="sd">        3. Clusters lines by angle into two groups (horizontal vs vertical).</span>
<span class="sd">        4. Estimates representative line lengths in each group.</span>
<span class="sd">        5. Removes lines shorter than a fraction of the median length.</span>
<span class="sd">        6. Returns the filtered horizontal, vertical, and combined line sets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frame : Any</span>
<span class="sd">            Input image/frame associated with the detected lines (used by</span>
<span class="sd">            the k-means noise discard step).</span>
<span class="sd">        lines : NDArray[np.integer] | None</span>
<span class="sd">            Array of line segments of shape (N, 4) in the form</span>
<span class="sd">            [x1, y1, x2, y2]. Must contain at least 3 lines.</span>
<span class="sd">        discardPercentageofMedian : float, default=0.8</span>
<span class="sd">            Fraction of the median line length used as a cutoff. Lines shorter</span>
<span class="sd">            than (median_length * discardPercentageofMedian) are discarded</span>
<span class="sd">            within each orientation group.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combinedLines : NDArray[np.integer]</span>
<span class="sd">            Array of filtered lines containing both horizontal and vertical</span>
<span class="sd">            segments, shape (M, 4).</span>
<span class="sd">        npHorizontal : NDArray[np.integer]</span>
<span class="sd">            Filtered horizontal lines, shape (H, 4).</span>
<span class="sd">        npVertical : NDArray[np.integer]</span>
<span class="sd">            Filtered vertical lines, shape (V, 4).</span>
<span class="sd">        kmeansVisuals : List[Frame]</span>
<span class="sd">            Visualizations of the k-means clustering step, showing lines</span>
<span class="sd">            colored by cluster.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are not enough input lines, if k-means discarding fails,</span>
<span class="sd">            if angle clustering fails, or if no horizontal/vertical lines remain</span>
<span class="sd">            after filtering.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Line orientation is determined via angle clustering into exactly two</span>
<span class="sd">          bins (horizontal-like and vertical-like).</span>
<span class="sd">        - Length thresholds are computed separately for horizontal and vertical</span>
<span class="sd">          groups using the median of the top longest lines in each group.</span>
<span class="sd">          </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough lines to perform noise discard.&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">kmeansVisuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kMeansNoiseDiscard</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No lines detected after k means noise discard.&quot;</span><span class="p">)</span>

        <span class="c1"># Loop until no more merges occur</span>
        <span class="n">prevLenLines</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">prevLenLines</span><span class="p">:</span>
            <span class="n">prevLenLines</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeLines</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">30</span><span class="p">)</span>

        <span class="n">angleClusters</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">tuple</span><span class="p">[</span>
                <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
                <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
                <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
                <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="o">|</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angleClusters</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">angleClusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Angle clustering failed.&quot;</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">centers_deg</span> <span class="o">=</span> <span class="n">angleClusters</span>

        <span class="c1"># Break into horizontal and vertical bins</span>
        <span class="n">bins</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="n">bins</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="n">horizontal_bin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">bins</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">centers_deg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">centers_deg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">180</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="n">vertical_bin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">horizontal_bin</span>  <span class="c1"># since there are exactly two</span>

        <span class="n">horizontalLines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]]</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">horizontal_bin</span><span class="p">]</span>
        <span class="n">verticalLines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]]</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">vertical_bin</span><span class="p">]</span>

        <span class="c1"># Compute lengths for horizontal lines</span>
        <span class="n">horizontal_lengths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">horizontalLines</span>
        <span class="p">]</span>
        <span class="n">vertical_lengths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">verticalLines</span>
        <span class="p">]</span>

        <span class="c1"># Sort descending by length</span>
        <span class="n">horizontal_lengths</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vertical_lengths</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Take the top 5 (or fewer if not enough lines)</span>
        <span class="n">top_horizontal</span> <span class="o">=</span> <span class="n">horizontal_lengths</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>  <span class="c1"># should only be 3 theoretically</span>
        <span class="n">top_vertical</span> <span class="o">=</span> <span class="n">vertical_lengths</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>

        <span class="c1"># Compute averages (handle case with fewer than 5 lines)</span>
        <span class="n">med_horizontal_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">top_horizontal</span><span class="p">)</span>
        <span class="n">med_vertical_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">top_vertical</span><span class="p">)</span>

        <span class="n">horizontalLinesFiltered</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discardShortLines</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">horizontalLines</span><span class="p">),</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">med_horizontal_length</span> <span class="o">*</span> <span class="n">discardPercentageofMedian</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">verticalLinesFiltered</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discardShortLines</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">verticalLines</span><span class="p">),</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">med_vertical_length</span> <span class="o">*</span> <span class="n">discardPercentageofMedian</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Convert to numpy arrays</span>
        <span class="k">if</span> <span class="n">horizontalLinesFiltered</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No horizontal lines detected after filtering.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verticalLinesFiltered</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No vertical lines detected after filtering.&quot;</span><span class="p">)</span>

        <span class="n">npHorizontal</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">horizontalLinesFiltered</span><span class="p">)</span>
        <span class="n">npVertical</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">verticalLinesFiltered</span><span class="p">)</span>

        <span class="n">combinedLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">npHorizontal</span><span class="p">,</span> <span class="n">npVertical</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">combinedLines</span><span class="p">,</span> <span class="n">npHorizontal</span><span class="p">,</span> <span class="n">npVertical</span><span class="p">,</span> <span class="n">kmeansVisuals</span></div>


<div class="viewcode-block" id="PanelSegmentor.kMeansNoiseDiscard">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.kMeansNoiseDiscard">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">kMeansNoiseDiscard</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span> <span class="n">Frame</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Frame</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cluster Hough lines by orientation using k-means and discard the smallest</span>
<span class="sd">        cluster as angular noise if it is sufficiently distinct.</span>

<span class="sd">        This function groups detected lines into `k` angle-based clusters (via</span>
<span class="sd">        `self.angleClusters`). The cluster with the fewest members is treated as</span>
<span class="sd">        noise and removed, unless:</span>
<span class="sd">        • Its center angle is too close to another cluster center, or</span>
<span class="sd">        • Its size exceeds a fixed threshold (i.e., it is not truly noise).</span>

<span class="sd">        Optionally, visual debug frames are produced showing each cluster drawn</span>
<span class="sd">        in a different color.</span>

<span class="sd">        Args:</span>
<span class="sd">            frame: Input image frame used only for generating visualization images.</span>
<span class="sd">            lines: Array of line segments of shape (N, 4), where each row is</span>
<span class="sd">                (x1, y1, x2, y2). Must not be None.</span>
<span class="sd">            k: Number of angle clusters to compute (default is 3).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of:</span>
<span class="sd">                • combined_lines: NDArray[np.integer]</span>
<span class="sd">                    Array of lines with the noise cluster removed. If no valid</span>
<span class="sd">                    noise cluster is detected, all input lines are returned.</span>
<span class="sd">                • visuals: list[Frame] | None</span>
<span class="sd">                    List of frames visualizing each cluster in a different color,</span>
<span class="sd">                    or None if clustering could not be performed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `lines` is None.</span>

<span class="sd">        Notes:</span>
<span class="sd">            • The smallest cluster is considered &quot;noise&quot; only if its center angle</span>
<span class="sd">                differs from all other cluster centers by more than `degreeThreshold`.</span>
<span class="sd">            • Clusters larger than a hardcoded size threshold are never discarded.</span>
<span class="sd">            • Uses `self.angle_diff`, `self.angleClusters`, and `VisualUtils.drawLines`.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No lines to discard noise from.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">kmeans</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">tuple</span><span class="p">[</span>
                <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
                <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
                <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
                <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="o">|</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angleClusters</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kmeans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">centers_deg</span> <span class="o">=</span> <span class="n">kmeans</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cluster centers (deg):&quot;</span><span class="p">,</span> <span class="n">centers_deg</span><span class="p">)</span>

        <span class="n">bins</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="n">bins</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="n">visuals</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Frame</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">colour</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bins</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">visuals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">VisualUtils</span><span class="o">.</span><span class="n">drawLines</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span> <span class="n">colour</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">cluster_sizes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bins</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster sizes: </span><span class="si">{</span><span class="n">cluster_sizes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Centres: </span><span class="si">{</span><span class="n">centers_deg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># lengths of each cluster</span>
        <span class="n">lengths</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bins</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># find the smallest cluster -&gt; noise</span>
        <span class="n">noiseCluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cluster_id</span><span class="p">:</span> <span class="n">lengths</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">])</span>

        <span class="c1"># Check if noise cluster is worth keeping</span>
        <span class="n">degreeThreshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">20.0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centers_deg</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">noiseCluster</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">MiscUtil</span><span class="o">.</span><span class="n">angleDiff</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">centers_deg</span><span class="p">[</span><span class="n">noiseCluster</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">degreeThreshold</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Noise cluster too close to other clusters, keeping all lines.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">visuals</span>

        <span class="c1"># if the smallest cluster is too big, ignore</span>
        <span class="k">if</span> <span class="n">lengths</span><span class="p">[</span><span class="n">noiseCluster</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No noise cluster detected. Keeping all lines. lengths: </span><span class="si">{</span><span class="n">lengths</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">visuals</span>

        <span class="c1"># combine the other two clusters</span>
        <span class="n">combined_lines</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">noiseCluster</span><span class="p">:</span>
                <span class="n">combined_lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">combinedLinesProcessed</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">combined_lines</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">combinedLinesProcessed</span><span class="p">,</span> <span class="n">visuals</span></div>


<div class="viewcode-block" id="PanelSegmentor.discardShortLines">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.discardShortLines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">discardShortLines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lengthThreshold</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">filtered_lines</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">:</span> <span class="nb">int</span>
            <span class="n">y1</span><span class="p">:</span> <span class="nb">int</span>
            <span class="n">x2</span><span class="p">:</span> <span class="nb">int</span>
            <span class="n">y2</span><span class="p">:</span> <span class="nb">int</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">line</span>
            <span class="n">length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;=</span> <span class="n">lengthThreshold</span><span class="p">:</span>
                <span class="n">filtered_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filtered_lines</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_lines</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>


<div class="viewcode-block" id="PanelSegmentor.calculateIntersections">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.calculateIntersections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculateIntersections</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">horizontalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span> <span class="n">verticalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute all intersection points between sets of horizontal and vertical lines.</span>

<span class="sd">        Each horizontal line is intersected with each vertical line using the</span>
<span class="sd">        standard line–line intersection formula. The result is grouped by</span>
<span class="sd">        horizontal line: each row in the output corresponds to one horizontal</span>
<span class="sd">        input line and contains the (x, y) intersection points with all vertical</span>
<span class="sd">        lines.</span>

<span class="sd">        Args:</span>
<span class="sd">            horizontalLines: Array of shape (H, 4) containing horizontal line</span>
<span class="sd">                segments as (x1, y1, x2, y2).</span>
<span class="sd">            verticalLines: Array of shape (V, 4) containing vertical line</span>
<span class="sd">                segments as (x1, y1, x2, y2).</span>

<span class="sd">        Returns:</span>
<span class="sd">            An array of shape (H, V, 2) with integer (x, y) intersection points,</span>
<span class="sd">            grouped per horizontal line, or None if no valid intersections are found</span>
<span class="sd">            or if either input is None.</span>

<span class="sd">        Notes:</span>
<span class="sd">            • Parallel line pairs are skipped.</span>
<span class="sd">            • The output is structured so each sub-array corresponds to one</span>
<span class="sd">                horizontal line’s intersections.</span>
<span class="sd">            • Coordinates are cast to int before returning.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">horizontalLines</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">verticalLines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">intersections</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">h_line</span> <span class="ow">in</span> <span class="n">horizontalLines</span><span class="p">:</span>
            <span class="n">x1_h</span><span class="p">,</span> <span class="n">y1_h</span><span class="p">,</span> <span class="n">x2_h</span><span class="p">,</span> <span class="n">y2_h</span> <span class="o">=</span> <span class="n">h_line</span>
            <span class="n">row_intersections</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># ← NEW list for this horizontal line</span>
            <span class="k">for</span> <span class="n">v_line</span> <span class="ow">in</span> <span class="n">verticalLines</span><span class="p">:</span>
                <span class="n">x1_v</span><span class="p">,</span> <span class="n">y1_v</span><span class="p">,</span> <span class="n">x2_v</span><span class="p">,</span> <span class="n">y2_v</span> <span class="o">=</span> <span class="n">v_line</span>

                <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1_h</span> <span class="o">-</span> <span class="n">x2_h</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1_v</span> <span class="o">-</span> <span class="n">y2_v</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">y1_h</span> <span class="o">-</span> <span class="n">y2_h</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1_v</span> <span class="o">-</span> <span class="n">x2_v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># parallel lines</span>

                <span class="n">px</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">x1_h</span> <span class="o">*</span> <span class="n">y2_h</span> <span class="o">-</span> <span class="n">y1_h</span> <span class="o">*</span> <span class="n">x2_h</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1_v</span> <span class="o">-</span> <span class="n">x2_v</span><span class="p">)</span>
                    <span class="o">-</span> <span class="p">(</span><span class="n">x1_h</span> <span class="o">-</span> <span class="n">x2_h</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1_v</span> <span class="o">*</span> <span class="n">y2_v</span> <span class="o">-</span> <span class="n">y1_v</span> <span class="o">*</span> <span class="n">x2_v</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>

                <span class="n">py</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">x1_h</span> <span class="o">*</span> <span class="n">y2_h</span> <span class="o">-</span> <span class="n">y1_h</span> <span class="o">*</span> <span class="n">x2_h</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1_v</span> <span class="o">-</span> <span class="n">y2_v</span><span class="p">)</span>
                    <span class="o">-</span> <span class="p">(</span><span class="n">y1_h</span> <span class="o">-</span> <span class="n">y2_h</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1_v</span> <span class="o">*</span> <span class="n">y2_v</span> <span class="o">-</span> <span class="n">y1_v</span> <span class="o">*</span> <span class="n">x2_v</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>

                <span class="n">row_intersections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">px</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">py</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">row_intersections</span><span class="p">:</span>
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_intersections</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">intersections</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>


<div class="viewcode-block" id="PanelSegmentor.endLines">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.endLines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">endLines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the first and last non-outlier line indices based on line angles.</span>

<span class="sd">        This method computes the orientation angle of each line segment using</span>
<span class="sd">        `atan2(dy, dx)`, normalizes angles to the range [0, 180), and identifies</span>
<span class="sd">        angular outliers via the interquartile range (IQR) method using</span>
<span class="sd">        `self.iqrOutliers`. The earliest and latest indices whose angles are not</span>
<span class="sd">        classified as outliers are returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            lines: Array of line segments with shape (N, 4), where each row is</span>
<span class="sd">                (x1, y1, x2, y2).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple (startline, endline) where:</span>
<span class="sd">                • startline is the index of the first non-outlier line.</span>
<span class="sd">                • endline is the index of the last non-outlier line.</span>

<span class="sd">        Notes:</span>
<span class="sd">            • Angles are computed in degrees and wrapped into [0, 180).</span>
<span class="sd">            • If all angles are considered outliers, the defaults are:</span>
<span class="sd">                startline = 0 and endline = len(lines) - 1.</span>
<span class="sd">            • Relies on `self.iqrOutliers` to return indices of outliers.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x1</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
        <span class="n">y1</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
        <span class="n">y2</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lines</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lines</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">lines</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>

        <span class="c1"># calculate deltas as abs to solve wrap-around</span>
        <span class="n">dx</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span>
        <span class="n">dy</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span>

        <span class="n">angles</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span> <span class="o">%</span> <span class="mi">180</span>

        <span class="n">outliers</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">MiscUtil</span><span class="o">.</span><span class="n">iqrOutliers</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">outliers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">outliers</span><span class="p">)</span>  <span class="c1"># convert to set for faster membership test</span>

        <span class="c1"># find first non-outlier index</span>
        <span class="n">startline</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outliers</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># find last non-outlier index</span>
        <span class="n">endline</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)))</span> <span class="k">if</span> <span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outliers</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">startline</span><span class="p">,</span> <span class="n">endline</span></div>


<div class="viewcode-block" id="PanelSegmentor.lineIntersection">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.lineIntersection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lineIntersection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">line1</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">line2</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the intersection point of two 2D lines.</span>

<span class="sd">        Each line is defined by four integer coordinates: (x1, y1, x2, y2).</span>

<span class="sd">        Args:</span>
<span class="sd">            line1: Line in the form (x1, y1, x2, y2) as integers.</span>
<span class="sd">            line2: Line in the form (x3, y3, x4, y4) as integers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A NumPy array of shape (2,) with the intersection point [x, y] as floats,</span>
<span class="sd">            or None if the lines are parallel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">line1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">line2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">x1</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">y1</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">x2</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">y2</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">x3</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">y3</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">x4</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">y4</span><span class="p">:</span> <span class="nb">int</span>

        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">line1</span>
        <span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="n">y4</span> <span class="o">=</span> <span class="n">line2</span>

        <span class="c1"># Line equations: A*x + B*y = C</span>
        <span class="n">A1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span>
        <span class="n">B1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span>
        <span class="n">C1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">B1</span> <span class="o">*</span> <span class="n">y1</span>

        <span class="n">A2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">y4</span> <span class="o">-</span> <span class="n">y3</span>
        <span class="n">B2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">x3</span> <span class="o">-</span> <span class="n">x4</span>
        <span class="n">C2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">B2</span> <span class="o">*</span> <span class="n">y3</span>

        <span class="n">det</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">B2</span> <span class="o">-</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">B1</span>
        <span class="k">if</span> <span class="n">det</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># Lines are parallel</span>

        <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span><span class="n">B2</span> <span class="o">*</span> <span class="n">C1</span> <span class="o">-</span> <span class="n">B1</span> <span class="o">*</span> <span class="n">C2</span><span class="p">)</span> <span class="o">/</span> <span class="n">det</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span><span class="n">A1</span> <span class="o">*</span> <span class="n">C2</span> <span class="o">-</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">C1</span><span class="p">)</span> <span class="o">/</span> <span class="n">det</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>


<div class="viewcode-block" id="PanelSegmentor.calculateCornerPoints">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.calculateCornerPoints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculateCornerPoints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">horizontalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">verticalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">topline</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">bottomline</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">leftline</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">rightline</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the four corner intersection points of a grid or rectangle.</span>

<span class="sd">        Args:</span>
<span class="sd">            horizontalLines: List or array of horizontal lines, each as (x1, y1, x2, y2) integers.</span>
<span class="sd">            verticalLines: List or array of vertical lines, each as (x1, y1, x2, y2) integers.</span>
<span class="sd">            topline: Index of the top horizontal line.</span>
<span class="sd">            bottomline: Index of the bottom horizontal line.</span>
<span class="sd">            leftline: Index of the left vertical line.</span>
<span class="sd">            rightline: Index of the right vertical line.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary with keys &#39;top_left&#39;, &#39;top_right&#39;, &#39;bottom_left&#39;, &#39;bottom_right&#39;.</span>
<span class="sd">            Each value is an np.ndarray of shape (2,) with [x, y] as floats, or None if lines are parallel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;top_left&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineIntersection</span><span class="p">(</span>
                <span class="n">horizontalLines</span><span class="p">[</span><span class="n">topline</span><span class="p">],</span> <span class="n">verticalLines</span><span class="p">[</span><span class="n">leftline</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="s2">&quot;top_right&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineIntersection</span><span class="p">(</span>
                <span class="n">horizontalLines</span><span class="p">[</span><span class="n">topline</span><span class="p">],</span> <span class="n">verticalLines</span><span class="p">[</span><span class="n">rightline</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="s2">&quot;bottom_left&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineIntersection</span><span class="p">(</span>
                <span class="n">horizontalLines</span><span class="p">[</span><span class="n">bottomline</span><span class="p">],</span> <span class="n">verticalLines</span><span class="p">[</span><span class="n">leftline</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="s2">&quot;bottom_right&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineIntersection</span><span class="p">(</span>
                <span class="n">horizontalLines</span><span class="p">[</span><span class="n">bottomline</span><span class="p">],</span> <span class="n">verticalLines</span><span class="p">[</span><span class="n">rightline</span><span class="p">]</span>
            <span class="p">),</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">corners</span></div>


<div class="viewcode-block" id="PanelSegmentor.rectifyGrid">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.rectifyGrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rectifyGrid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Frame</span><span class="p">,</span> <span class="n">corners</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rectify a quadrilateral region of an image to a top-down rectangular view.</span>

<span class="sd">        This function takes the four corner points of a grid (or any quadrilateral)</span>
<span class="sd">        in an image and computes a perspective transform (homography) to produce</span>
<span class="sd">        a rectified, axis-aligned rectangle containing the region.</span>

<span class="sd">        Args:</span>
<span class="sd">            image (np.ndarray): Input image as a NumPy array (H x W x C or H x W).</span>
<span class="sd">            corners (dict[str, np.ndarray]): Dictionary of corner points with keys:</span>
<span class="sd">                - &quot;top_left&quot;</span>
<span class="sd">                - &quot;top_right&quot;</span>
<span class="sd">                - &quot;bottom_right&quot;</span>
<span class="sd">                - &quot;bottom_left&quot;</span>
<span class="sd">                Each value should be a NumPy array of shape (2,) representing [x, y] coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Rectified image cropped and warped to a rectangle defined</span>
<span class="sd">            by the maximum width and height of the quadrilateral.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If any corner is None or if the homography cannot be computed.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The output rectangle will have its top-left corner at (0, 0).</span>
<span class="sd">            - Width is determined by the maximum of the top and bottom edge lengths.</span>
<span class="sd">            - Height is determined by the maximum of the left and right edge lengths.</span>
<span class="sd">            - The method logs corner information for debugging purposes.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Corner points:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">corners</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Check if any points are the same</span>
        <span class="n">pts</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">corners</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unique corners: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">pts_src</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">corners</span><span class="p">[</span><span class="s2">&quot;top_left&quot;</span><span class="p">],</span>
                <span class="n">corners</span><span class="p">[</span><span class="s2">&quot;top_right&quot;</span><span class="p">],</span>
                <span class="n">corners</span><span class="p">[</span><span class="s2">&quot;bottom_right&quot;</span><span class="p">],</span>
                <span class="n">corners</span><span class="p">[</span><span class="s2">&quot;bottom_left&quot;</span><span class="p">],</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">topLeft</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="s2">&quot;top_left&quot;</span><span class="p">]</span>
        <span class="n">topRight</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="s2">&quot;top_right&quot;</span><span class="p">]</span>
        <span class="n">bottomLeft</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="s2">&quot;bottom_left&quot;</span><span class="p">]</span>
        <span class="n">bottomRight</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="s2">&quot;bottom_right&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">topLeft</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">topRight</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">bottomLeft</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">bottomRight</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more corner points are None; cannot rectify grid.&quot;</span><span class="p">)</span>

        <span class="n">widthTop</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">topRight</span> <span class="o">-</span> <span class="n">topLeft</span><span class="p">))</span>
        <span class="n">widthBottom</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bottomRight</span> <span class="o">-</span> <span class="n">bottomLeft</span><span class="p">))</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">widthTop</span><span class="p">,</span> <span class="n">widthBottom</span><span class="p">))</span>

        <span class="n">heightLeft</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bottomLeft</span> <span class="o">-</span> <span class="n">topLeft</span><span class="p">))</span>
        <span class="n">heightRight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bottomRight</span> <span class="o">-</span> <span class="n">topRight</span><span class="p">))</span>
        <span class="n">height</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">heightLeft</span><span class="p">,</span> <span class="n">heightRight</span><span class="p">))</span>

        <span class="n">ptsDst</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Compute homography</span>
        <span class="n">H</span><span class="p">:</span> <span class="n">MatLike</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">findHomography</span><span class="p">(</span><span class="n">pts_src</span><span class="p">,</span> <span class="n">ptsDst</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Homography could not be computed; check corner points.&quot;</span><span class="p">)</span>

        <span class="c1"># Warp image</span>
        <span class="n">rectified</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rectified</span></div>


<div class="viewcode-block" id="PanelSegmentor.homographyTransform">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.homographyTransform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">homographyTransform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">Frame</span><span class="p">,</span>
        <span class="n">horizontalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">verticalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a homography-based perspective correction to an image using detected grid lines.</span>

<span class="sd">        This method selects the outermost horizontal and vertical lines from the detected grid,</span>
<span class="sd">        computes the four corner points of the grid via line intersections, and then rectifies</span>
<span class="sd">        the image so that the grid appears fronto-parallel.</span>

<span class="sd">        Steps:</span>
<span class="sd">            1. Sort horizontal lines by their average y-coordinate and vertical lines by their average x-coordinate.</span>
<span class="sd">            2. Identify the topmost, bottommost, leftmost, and rightmost lines using `endLines`.</span>
<span class="sd">            3. Compute the corner points where these lines intersect using `calculateCornerPoints`.</span>
<span class="sd">            4. Rectify the image using the computed corners via `rectifyGrid`.</span>

<span class="sd">        Args:</span>
<span class="sd">            image (Frame): The input image to be transformed.</span>
<span class="sd">            horizontalLines (NDArray[np.integer]): Array of shape (N, 4) containing detected horizontal lines</span>
<span class="sd">                in the format (x1, y1, x2, y2).</span>
<span class="sd">            verticalLines (NDArray[np.integer]): Array of shape (M, 4) containing detected vertical lines</span>
<span class="sd">                in the format (x1, y1, x2, y2).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Frame: The rectified image after perspective correction.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `horizontalLines` or `verticalLines` is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">horizontalLines</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">verticalLines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Horizontal or vertical lines are None.&quot;</span><span class="p">)</span>
        <span class="n">avgY</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">horizontalLines</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">horizontalLines</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">sortIdx</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">avgY</span><span class="p">)</span>
        <span class="n">horizontalLines</span> <span class="o">=</span> <span class="n">horizontalLines</span><span class="p">[</span><span class="n">sortIdx</span><span class="p">]</span>

        <span class="n">avgX</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">verticalLines</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">verticalLines</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">verticalLines</span> <span class="o">=</span> <span class="n">verticalLines</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">avgX</span><span class="p">)]</span>

        <span class="n">topline</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">bottomline</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">leftline</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">rightline</span><span class="p">:</span> <span class="nb">int</span>

        <span class="n">topline</span><span class="p">,</span> <span class="n">bottomline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endLines</span><span class="p">(</span><span class="n">horizontalLines</span><span class="p">)</span>
        <span class="n">leftline</span><span class="p">,</span> <span class="n">rightline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endLines</span><span class="p">(</span><span class="n">verticalLines</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Selected grid lines:&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;topline: </span><span class="si">{</span><span class="n">topline</span><span class="si">}</span><span class="s2">, bottomline: </span><span class="si">{</span><span class="n">bottomline</span><span class="si">}</span><span class="s2">, leftline: </span><span class="si">{</span><span class="n">leftline</span><span class="si">}</span><span class="s2">, rightline: </span><span class="si">{</span><span class="n">rightline</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate Via intersections</span>

        <span class="n">corners</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateCornerPoints</span><span class="p">(</span>
            <span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span><span class="p">,</span> <span class="n">topline</span><span class="p">,</span> <span class="n">bottomline</span><span class="p">,</span> <span class="n">leftline</span><span class="p">,</span> <span class="n">rightline</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rectifyGrid</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">corners</span><span class="p">)</span></div>


<div class="viewcode-block" id="PanelSegmentor.calculateGridSpacings">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.calculateGridSpacings">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculateGridSpacings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">horizontalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">verticalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">isHorizontal</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">tolerancePercent</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the spacing between grid lines in an image based on detected intersections.</span>

<span class="sd">        This method analyzes intersections between horizontal and vertical lines to determine</span>
<span class="sd">        the most likely number of evenly spaced columns or rows along a specified axis</span>
<span class="sd">        (horizontal or vertical). It iteratively adjusts a guess for the spacing, considering</span>
<span class="sd">        a tolerance, and returns whether a regular spacing pattern was detected along with</span>
<span class="sd">        the estimated count.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        horizontalLines : NDArray[np.integer]</span>
<span class="sd">            Array of horizontal lines in the format (x1, y1, x2, y2).</span>
<span class="sd">        verticalLines : NDArray[np.integer]</span>
<span class="sd">            Array of vertical lines in the format (x1, y1, x2, y2).</span>
<span class="sd">        isHorizontal : bool</span>
<span class="sd">            If True, compute spacings along the horizontal axis (columns),</span>
<span class="sd">            otherwise along the vertical axis (rows).</span>
<span class="sd">        tolerancePercent : float, optional</span>
<span class="sd">            Percentage of the axis length allowed as deviation from the expected spacing</span>
<span class="sd">            to still be considered a valid interval. Default is 5.0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray | None</span>
<span class="sd">            An array of shape (N, 2), where N is the number of grid lines analyzed.</span>
<span class="sd">            Each row contains:</span>
<span class="sd">            [spacingDetected: bool, estimatedCount: int]</span>
<span class="sd">            - `spacingDetected` indicates whether a regular spacing pattern was found.</span>
<span class="sd">            - `estimatedCount` is the estimated number of evenly spaced segments along the axis.</span>
<span class="sd">            Returns None if no intersections are found.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no intersections between horizontal and vertical lines are found.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method sorts intersections along the axis to ensure proper spacing calculation.</span>
<span class="sd">        - It iteratively guesses the number of columns/rows (`colsGeuss`) and checks distances</span>
<span class="sd">          between intersections against the guessed spacing with a specified tolerance.</span>
<span class="sd">        - The detection algorithm attempts to handle multiple panels by doubling and halving</span>
<span class="sd">          the guessed count when necessary.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">axisLength</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="k">if</span> <span class="n">isHorizontal</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span>

        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">isHorizontal</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">isHorizontal</span><span class="p">:</span>
            <span class="n">horizontalLines</span> <span class="o">=</span> <span class="n">horizontalLines</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">horizontalLines</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">horizontalLines</span> <span class="o">=</span> <span class="n">horizontalLines</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">horizontalLines</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])]</span>

        <span class="n">intersections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateIntersections</span><span class="p">(</span><span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">intersections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No intersections found between horizontal and vertical lines.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># ensure sorted</span>
        <span class="n">intersections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">row</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">])]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">intersections</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span>
        <span class="p">)</span>

        <span class="n">detections</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">horizontalLine</span> <span class="ow">in</span> <span class="n">intersections</span><span class="p">:</span>
            <span class="n">spacingDetected</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">finallyReached</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">colsGeuss</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">distancesTemp</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">horizontalLine</span><span class="p">)):</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="n">horizontalLine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pi</span> <span class="o">=</span> <span class="n">horizontalLine</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">isHorizontal</span><span class="p">:</span>
                    <span class="n">distancesTemp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1"># X distance</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distancesTemp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># Y distance</span>

            <span class="n">distances</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distancesTemp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;DISTANCE CHECK START&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;IsHorizontal: </span><span class="si">{</span><span class="n">isHorizontal</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ColsGuess: </span><span class="si">{</span><span class="n">colsGeuss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;distances: </span><span class="si">{</span><span class="n">distances</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">while</span> <span class="n">finallyReached</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">SpacingGuess</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">axisLength</span> <span class="o">/</span> <span class="n">colsGeuss</span>
                <span class="n">toleranceFactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span><span class="n">tolerancePercent</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="n">axisLength</span>

                <span class="c1"># check if point is within tolerance</span>

                <span class="n">pointer1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">pointer2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">successCount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">dist3</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">pointer2</span><span class="p">]</span> <span class="o">-</span> <span class="n">distances</span><span class="p">[</span><span class="n">pointer1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance between points: </span><span class="si">{</span><span class="n">dist3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SpacingGuess: </span><span class="si">{</span><span class="n">SpacingGuess</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">abs</span><span class="p">((</span><span class="n">distances</span><span class="p">[</span><span class="n">pointer2</span><span class="p">]</span> <span class="o">-</span> <span class="n">distances</span><span class="p">[</span><span class="n">pointer1</span><span class="p">])</span> <span class="o">-</span> <span class="n">SpacingGuess</span><span class="p">)</span>
                        <span class="o">&lt;</span> <span class="n">toleranceFactor</span>
                    <span class="p">):</span>
                        <span class="n">successCount</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">pointer1</span> <span class="o">=</span> <span class="n">pointer2</span>
                        <span class="n">pointer2</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;SUCCESS:&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pointer2</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="mi">1</span>  <span class="c1"># since pointer1 HAS to be included pointer2 moves on</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;FAIL:&quot;</span><span class="p">)</span>

                <span class="c1"># regular fail case increase colsGeuss</span>
                <span class="k">if</span> <span class="n">successCount</span> <span class="o">!=</span> <span class="n">colsGeuss</span> <span class="ow">and</span> <span class="n">spacingDetected</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">colsGeuss</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">colsGeuss</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">verticalLines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># give up case</span>
                        <span class="n">spacingDetected</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">detections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">detections</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                        <span class="k">break</span>

                <span class="c1"># success case double incase of more panels and try again</span>
                <span class="k">elif</span> <span class="n">successCount</span> <span class="o">==</span> <span class="n">colsGeuss</span><span class="p">:</span>
                    <span class="n">spacingDetected</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">colsGeuss</span> <span class="o">*=</span> <span class="mi">2</span>

                <span class="c1"># if double check fails half colsGeuss and break</span>
                <span class="k">elif</span> <span class="n">successCount</span> <span class="o">!=</span> <span class="n">colsGeuss</span> <span class="ow">and</span> <span class="n">spacingDetected</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">colsGeuss</span> <span class="o">//=</span> <span class="mi">2</span>
                    <span class="n">detections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">detections</span><span class="p">,</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">colsGeuss</span><span class="p">]))</span>
                    <span class="n">finallyReached</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;DISTANCE CHECK END&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;detections: </span><span class="si">{</span><span class="n">detections</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">detections</span></div>


<div class="viewcode-block" id="PanelSegmentor.determineGridLines">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.determineGridLines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">determineGridLines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">horizontalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span> <span class="n">verticalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Determine the most likely regular grid spacings for horizontal and vertical lines.</span>

<span class="sd">          This method analyzes detected horizontal and vertical lines to estimate the number of</span>
<span class="sd">          evenly spaced rows and columns in a grid. It uses `calculateGridSpacings` to detect</span>
<span class="sd">          candidate spacings along each axis, filters out invalid detections, and returns</span>
<span class="sd">          the median spacing for each axis, ensuring consistency with the mode.</span>

<span class="sd">          Parameters</span>
<span class="sd">          ----------</span>
<span class="sd">          horizontalLines : NDArray[np.integer]</span>
<span class="sd">              Array of detected horizontal lines, shape (N, 4), where each row is (x1, y1, x2, y2).</span>
<span class="sd">          verticalLines : NDArray[np.integer]</span>
<span class="sd">              Array of detected vertical lines, shape (M, 4), where each row is (x1, y1, x2, y2).</span>

<span class="sd">          Returns</span>
<span class="sd">          -------</span>
<span class="sd">          tuple[int, int]</span>
<span class="sd">              A tuple `(horizontalSpacing, verticalSpacing)` representing the estimated</span>
<span class="sd">              number of evenly spaced segments along the horizontal and vertical axes.</span>

<span class="sd">          Raises</span>
<span class="sd">          ------</span>
<span class="sd">          ValueError</span>
<span class="sd">              - If no grid spacings are detected on either axis.</span>
<span class="sd">              - If no valid spacings remain after filtering.</span>
<span class="sd">              - If the median and mode of the detected spacings do not match, indicating</span>
<span class="sd">                inconsistent or unreliable detections.</span>

<span class="sd">          Notes</span>
<span class="sd">          -----</span>
<span class="sd">          - Filtering ensures only grid lines with a detected regular spacing pattern are considered.</span>
<span class="sd">          - The median of the filtered spacings is used as the primary estimate, with the mode</span>
<span class="sd">            used as a consistency check.</span>
<span class="sd">          - This method assumes that `calculateGridSpacings` returns an array where each row</span>
<span class="sd">            contains `[spacingDetected: bool, estimatedCount: int]`.</span>
<span class="sd">          </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">horizontalDetections</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateGridSpacings</span><span class="p">(</span>
            <span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span><span class="p">,</span> <span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">verticalDetections</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateGridSpacings</span><span class="p">(</span>
            <span class="n">verticalLines</span><span class="p">,</span> <span class="n">horizontalLines</span><span class="p">,</span> <span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">horizontalDetections</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">verticalDetections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No grid spacings detected.&quot;</span><span class="p">)</span>

        <span class="n">horizontalFiltered</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">horizontalDetections</span><span class="p">[</span>
            <span class="n">horizontalDetections</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span>
        <span class="p">]</span>
        <span class="n">verticalFiltered</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">verticalDetections</span><span class="p">[</span>
            <span class="n">verticalDetections</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span>
        <span class="p">]</span>
        <span class="c1"># true tuple entries</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">horizontalFiltered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">verticalFiltered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Should never get here</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid grid spacings detected.&quot;</span><span class="p">)</span>

        <span class="c1"># get the spacings only</span>
        <span class="n">horizontalSpacings</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">horizontalFiltered</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">verticalSpacings</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">verticalFiltered</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">horizontalSpacing</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">MiscUtil</span><span class="o">.</span><span class="n">safeInt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">horizontalSpacings</span><span class="p">))</span>
        <span class="n">verticalSpacing</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">MiscUtil</span><span class="o">.</span><span class="n">safeInt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">verticalSpacings</span><span class="p">))</span>

        <span class="n">h_mode</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">MiscUtil</span><span class="o">.</span><span class="n">getMode</span><span class="p">(</span><span class="n">horizontalSpacings</span><span class="p">)</span>
        <span class="n">v_mode</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">MiscUtil</span><span class="o">.</span><span class="n">getMode</span><span class="p">(</span><span class="n">verticalSpacings</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">horizontalSpacing</span> <span class="o">!=</span> <span class="n">h_mode</span> <span class="ow">or</span> <span class="n">verticalSpacing</span> <span class="o">!=</span> <span class="n">v_mode</span><span class="p">:</span>
            <span class="c1"># If the median and mode do not match, it indicates a potential error in spacing detection.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Median and mode of grid spacings do not match. Check grid lines.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">horizontalSpacing</span><span class="p">,</span> <span class="n">verticalSpacing</span></div>


<div class="viewcode-block" id="PanelSegmentor.execute">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image</span><span class="p">,</span>
        <span class="n">frameCount</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">logPath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">visuals</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visualPath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">diagonstics</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Frame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the full visual segmentation and rectification pipeline on a frame.</span>

<span class="sd">        This method performs grid line detection, homography rectification, spacing</span>
<span class="sd">        estimation, and cell extraction on the input image. Each detected cell is</span>
<span class="sd">        then resized to a target aspect ratio and optionally saved along with</span>
<span class="sd">        diagnostic and visualization outputs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : Frame</span>
<span class="sd">            Input image/frame to process.</span>
<span class="sd">        frameCount : int</span>
<span class="sd">            Index of the frame being processed (used for logging and output naming).</span>
<span class="sd">        logPath : str, optional</span>
<span class="sd">            Directory where log files should be written.</span>
<span class="sd">        visuals : bool, optional</span>
<span class="sd">            If True, saves intermediate and final visualization images to disk.</span>
<span class="sd">        visualPath : str, optional</span>
<span class="sd">            Base directory for saving visualization outputs.</span>
<span class="sd">        diagonstics : bool, optional</span>
<span class="sd">            If True, enables per-frame diagnostic logging.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Frame]</span>
<span class="sd">            List of rectified and aspect-ratio-adjusted cell images extracted from</span>
<span class="sd">            the input frame.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no cells are extracted from the image.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Pipeline steps:</span>
<span class="sd">            1. Detect grid lines in the original image.</span>
<span class="sd">            2. Apply homography to rectify the grid.</span>
<span class="sd">            3. Re-run line detection on the rectified image.</span>
<span class="sd">            4. Estimate horizontal and vertical spacing.</span>
<span class="sd">            5. Split the rectified image into grid cells.</span>
<span class="sd">            6. Stretch each cell to the target aspect ratio.</span>
<span class="sd">            7. Optionally save visualizations and diagnostics.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resetParameters</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">logPath</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">diagonstics</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">MiscUtil</span><span class="o">.</span><span class="n">setupLogger</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segmentLogger</span><span class="si">{</span><span class="n">frameCount</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">logPath</span><span class="p">)</span>
        <span class="c1">#image = cv.cvtColor(image, cv.COLOR_BGR2RGB)</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span><span class="p">,</span> <span class="n">kMeansVisualsMain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridPipeline</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineCount</span>
        <span class="p">)</span>
        <span class="n">originalArea</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        

        <span class="n">rectified</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">homographyTransform</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span><span class="p">)</span>
        
        <span class="n">rectifedArea</span> <span class="o">=</span> <span class="n">rectified</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rectified</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original Area: </span><span class="si">{</span><span class="n">originalArea</span><span class="si">}</span><span class="s2">, Rectified Area: </span><span class="si">{</span><span class="n">rectifedArea</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">rectifiedLines</span><span class="p">,</span> <span class="n">rectifiedHoriz</span><span class="p">,</span> <span class="n">rectifiedVert</span><span class="p">,</span> <span class="n">kMeansVisualsRectified</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rectifiedPipeline</span><span class="p">(</span><span class="n">rectified</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineCount</span> <span class="o">*</span> <span class="p">(</span><span class="n">rectifedArea</span> <span class="o">/</span> <span class="n">originalArea</span><span class="p">)),</span> <span class="n">logPath</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">hspacing</span><span class="p">,</span> <span class="n">vspacing</span><span class="p">,</span> <span class="n">gridRectified</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacingPipeline</span><span class="p">(</span><span class="n">rectified</span><span class="p">,</span> <span class="n">rectifiedHoriz</span><span class="p">,</span> <span class="n">rectifiedVert</span><span class="p">)</span>

        <span class="n">cells</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">VisualUtils</span><span class="o">.</span><span class="n">splitImageToGrid</span><span class="p">(</span>
            <span class="n">rectified</span><span class="p">,</span> <span class="n">vspacing</span><span class="p">,</span> <span class="n">hspacing</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;H Spacing: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">hspacing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;V Spacing: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">vspacing</span><span class="p">)</span>
        
        <span class="n">reaspectedFrames</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Frame</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">:</span>
            <span class="n">reaspectedFrames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">VisualUtils</span><span class="o">.</span><span class="n">stretchToAspectRatio</span><span class="p">(</span>
                    <span class="n">cell</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">aspectRatio</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">aspectRatio</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">reaspectedFrames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reaspectedFrames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No cells extracted from image.&quot;</span><span class="p">)</span>
        
        <span class="c1"># crop the rectified image in 5 pixel borders to remove edge artifacts</span>
        <span class="n">rectified</span> <span class="o">=</span> <span class="n">rectified</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">gridRectified</span> <span class="o">=</span> <span class="n">gridRectified</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>   

        <span class="n">original_with_lines</span> <span class="o">=</span> <span class="n">VisualUtils</span><span class="o">.</span><span class="n">drawLines</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">rectified_with_lines</span> <span class="o">=</span> <span class="n">VisualUtils</span><span class="o">.</span><span class="n">drawLines</span><span class="p">(</span><span class="n">rectified</span><span class="p">,</span> <span class="n">rectifiedLines</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">visuals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visualUtil</span><span class="o">.</span><span class="n">savePanelArray</span><span class="p">(</span>
                <span class="n">reaspectedFrames</span><span class="p">,</span>
                <span class="n">frameCount</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">visualPath</span> <span class="o">+</span> <span class="s2">&quot;/segmentation/cells&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visualUtil</span><span class="o">.</span><span class="n">saveFrame</span><span class="p">(</span>
                <span class="n">original_with_lines</span><span class="p">,</span>
                <span class="s2">&quot;original_with_lines&quot;</span><span class="p">,</span>
                <span class="n">frameCount</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">visualPath</span> <span class="o">+</span> <span class="s2">&quot;/segmentation&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visualUtil</span><span class="o">.</span><span class="n">saveFrame</span><span class="p">(</span>
                <span class="n">rectified_with_lines</span><span class="p">,</span>
                <span class="s2">&quot;rectified_with_lines&quot;</span><span class="p">,</span>
                <span class="n">frameCount</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">visualPath</span> <span class="o">+</span> <span class="s2">&quot;/segmentation&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visualUtil</span><span class="o">.</span><span class="n">saveFrame</span><span class="p">(</span>
                <span class="n">gridRectified</span><span class="p">,</span>
                <span class="s2">&quot;grid_rectified&quot;</span><span class="p">,</span>
                <span class="n">frameCount</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">visualPath</span> <span class="o">+</span> <span class="s2">&quot;/segmentation&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">kMeansVisualsMain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">visual</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kMeansVisualsMain</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visualUtil</span><span class="o">.</span><span class="n">saveFrame</span><span class="p">(</span>
                        <span class="n">visual</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;kmeans_main_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">frameCount</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                        <span class="n">visualPath</span> <span class="o">+</span> <span class="s2">&quot;/diagonstics&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">kMeansVisualsRectified</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">visual</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kMeansVisualsRectified</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visualUtil</span><span class="o">.</span><span class="n">saveFrame</span><span class="p">(</span>
                        <span class="n">visual</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;kmeans_rectified_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">frameCount</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                        <span class="n">visualPath</span> <span class="o">+</span> <span class="s2">&quot;/diagonstics&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">reaspectedFrames</span></div>


<div class="viewcode-block" id="PanelSegmentor.rectifiedPipeline">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.rectifiedPipeline">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rectifiedPipeline</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Frame</span><span class="p">,</span> <span class="n">expectedLines</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">logPath</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="nb">list</span><span class="p">[</span><span class="n">Frame</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the full rectified-image grid detection pipeline.</span>

<span class="sd">        This method preprocesses a rectified image, detects line segments, augments</span>
<span class="sd">        them with image-border lines, and then groups and filters the lines into</span>
<span class="sd">        horizontal and vertical sets suitable for grid reconstruction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : Frame</span>
<span class="sd">            Rectified input image to process.</span>
<span class="sd">        expectedLines : int</span>
<span class="sd">            Approximate number of line segments expected in the image, used to tune</span>
<span class="sd">            the line detection stage.</span>
<span class="sd">        logPath : str</span>
<span class="sd">            Directory path used for resetting parameters and logging context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : NDArray[np.integer]</span>
<span class="sd">            Array of all detected and augmented line segments in (x1, y1, x2, y2)</span>
<span class="sd">            format.</span>
<span class="sd">        horizontalLines : NDArray[np.integer]</span>
<span class="sd">            Subset of `lines` corresponding to horizontal grid lines.</span>
<span class="sd">        verticalLines : NDArray[np.integer]</span>
<span class="sd">            Subset of `lines` corresponding to vertical grid lines.</span>
<span class="sd">        kMeansVisuals : list[Frame] or None</span>
<span class="sd">            Optional list of diagnostic visualization frames from the clustering</span>
<span class="sd">            and filtering stages.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no lines are detected at any stage of the rectified pipeline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Pipeline steps:</span>
<span class="sd">            1. Reset internal parameters based on image shape.</span>
<span class="sd">            2. Preprocess the image (denoising, blurring, downsampling).</span>
<span class="sd">            3. Detect line segments.</span>
<span class="sd">            4. Add border lines corresponding to the image edges.</span>
<span class="sd">            5. Group and filter lines into horizontal and vertical sets.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing image of shape: </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resetParameters</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">logPath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;NORMALIZER&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Width: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s2">, Height: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">blurred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preProcess</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoiseLambdaWeight</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoiseMeanKernelSize</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoiuseGaussianSigma</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoiseDownsampleFactor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">lineOutput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineDetection</span><span class="p">(</span><span class="n">blurred</span><span class="p">,</span> <span class="n">expectedLines</span><span class="p">)</span>
        <span class="c1"># Add Corner Lines</span>
        <span class="k">if</span> <span class="n">lineOutput</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No lines detected in rectified pipeline.&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">lineOutput</span>
        <span class="n">topLine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">bottomLine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">leftLine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">rightLine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">leftLine</span><span class="p">,</span> <span class="n">topLine</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">bottomLine</span><span class="p">,</span> <span class="n">rightLine</span><span class="p">))</span>
        <span class="n">groupAndFilterOutput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupAndFilter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">groupAndFilterOutput</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No lines detected in rectified pipeline.&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span><span class="p">,</span> <span class="n">kMeansVisuals</span> <span class="o">=</span> <span class="n">groupAndFilterOutput</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span><span class="p">,</span> <span class="n">kMeansVisuals</span></div>


<div class="viewcode-block" id="PanelSegmentor.gridPipeline">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.gridPipeline">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gridPipeline</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Frame</span><span class="p">,</span> <span class="n">expectedLines</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">logPath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="nb">list</span><span class="p">[</span><span class="n">Frame</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the full grid line detection pipeline on an image.</span>

<span class="sd">        This method preprocesses the input image, detects line segments, and groups</span>
<span class="sd">        and filters them into horizontal and vertical line sets suitable for grid</span>
<span class="sd">        estimation and rectification.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : Frame</span>
<span class="sd">            Input image/frame to process.</span>
<span class="sd">        expectedLines : int</span>
<span class="sd">            Approximate number of line segments expected in the image, used to tune</span>
<span class="sd">            the line detection stage.</span>
<span class="sd">        logPath : str, optional</span>
<span class="sd">            Directory path used for resetting parameters and logging context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : NDArray[np.integer]</span>
<span class="sd">            Array of all detected line segments in (x1, y1, x2, y2) format.</span>
<span class="sd">        horizontalLines : NDArray[np.integer]</span>
<span class="sd">            Subset of `lines` corresponding to horizontal grid lines.</span>
<span class="sd">        verticalLines : NDArray[np.integer]</span>
<span class="sd">            Subset of `lines` corresponding to vertical grid lines.</span>
<span class="sd">        kMeansVisuals : list[Frame] or None</span>
<span class="sd">            Optional list of diagnostic visualization frames from the clustering</span>
<span class="sd">            and filtering stages.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no lines are detected at any stage of the grid pipeline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Pipeline steps:</span>
<span class="sd">            1. Reset internal parameters based on image shape.</span>
<span class="sd">            2. Preprocess the image (denoising, blurring, downsampling).</span>
<span class="sd">            3. Detect line segments.</span>
<span class="sd">            4. Group and filter lines into horizontal and vertical sets.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing image of shape: </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resetParameters</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">logPath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;NORMALIZER&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Width: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s2">, Height: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">blurred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preProcess</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoiseLambdaWeight</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoiseMeanKernelSize</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoiuseGaussianSigma</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoiseDownsampleFactor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">lineOutput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineDetection</span><span class="p">(</span><span class="n">blurred</span><span class="p">,</span> <span class="n">expectedLines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lineOutput</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No lines detected in rectified pipeline.&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">lineOutput</span>
        <span class="c1"># showImages([image, blurred, edges], [&quot;Original&quot;, &quot;Preprocessed&quot;, &quot;Edges&quot;])</span>
        <span class="n">groupAndFilterOutput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupAndFilter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">groupAndFilterOutput</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No lines detected in rectified pipeline.&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span><span class="p">,</span> <span class="n">kMeansVisuals</span> <span class="o">=</span> <span class="n">groupAndFilterOutput</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span><span class="p">,</span> <span class="n">kMeansVisuals</span></div>


<div class="viewcode-block" id="PanelSegmentor.spacingPipeline">
<a class="viewcode-back" href="../../../_autosummary/P2DingoCV.PanelSegmentation.PanelSegmentor.html#P2DingoCV.PanelSegmentation.PanelSegmentor.PanelSegmentor.spacingPipeline">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spacingPipeline</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">Frame</span><span class="p">,</span>
        <span class="n">horizontalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
        <span class="n">verticalLines</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Frame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate grid spacing from detected line sets and render a grid overlay.</span>

<span class="sd">        This method determines the horizontal and vertical grid spacings from</span>
<span class="sd">        previously detected horizontal and vertical line segments, logs the</span>
<span class="sd">        results, and draws the inferred grid onto the rectified image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : Frame</span>
<span class="sd">            Rectified image on which the grid spacing is estimated and visualized.</span>
<span class="sd">        horizontalLines : NDArray[np.integer]</span>
<span class="sd">            Array of horizontal line segments in (x1, y1, x2, y2) format.</span>
<span class="sd">        verticalLines : NDArray[np.integer]</span>
<span class="sd">            Array of vertical line segments in (x1, y1, x2, y2) format.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        horizontalSpacing : int</span>
<span class="sd">            Estimated spacing between horizontal grid lines (in pixels).</span>
<span class="sd">        verticalSpacing : int</span>
<span class="sd">            Estimated spacing between vertical grid lines (in pixels).</span>
<span class="sd">        gridOnRectified : Frame</span>
<span class="sd">            Copy of the input image with the estimated grid spacing overlaid.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This step assumes the input image has already been rectified such that</span>
<span class="sd">        grid lines are approximately axis-aligned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">horizontalSpacing</span><span class="p">,</span> <span class="n">verticalSpacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determineGridLines</span><span class="p">(</span>
            <span class="n">horizontalLines</span><span class="p">,</span> <span class="n">verticalLines</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Determined Spacings - Horizontal: </span><span class="si">%s</span><span class="s2"> | Vertical: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">horizontalSpacing</span><span class="p">,</span>
            <span class="n">verticalSpacing</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">gridOnRectified</span> <span class="o">=</span> <span class="n">VisualUtils</span><span class="o">.</span><span class="n">drawSpacingLines</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span> <span class="n">verticalSpacing</span><span class="p">,</span> <span class="n">verticalSpacing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>
        <span class="p">)</span>
   
        <span class="k">return</span> <span class="n">horizontalSpacing</span><span class="p">,</span> <span class="n">verticalSpacing</span><span class="p">,</span> <span class="n">gridOnRectified</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Cormac Morrison.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>